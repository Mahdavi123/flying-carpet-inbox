import { Plugin } from 'prosemirror-state';
import { TableMap, tableNodeTypes } from 'prosemirror-tables-ts';
import { Decoration, DecorationSet } from 'prosemirror-view';
import { domCellAround, otherResizeHandle, otherResizing, parentNode, parseStyle, setNodeStyle, tableRowResizeKey as key } from './utils';
class TableRowView {
    ignoreMutation(record) {
        return record.type === 'attributes' && record.attributeName === 'style' && record.target.nodeName === 'TR';
    }
}
export function rowResizing() {
    const handleWidth = 5;
    let plugin = new Plugin({
        key,
        state: {
            init(_, state) {
                this.spec.props.nodeViews[tableNodeTypes(state.schema).row.name] = (_node, _view) => new TableRowView();
                return new ResizeState(-1, null);
            },
            apply(tr, prev) {
                return prev.apply(tr);
            }
        },
        props: {
            attributes(state) {
                if (otherResizeHandle(key, state)) {
                    return null;
                }
                let pluginState = key.getState(state);
                return pluginState.activeHandle > -1 ? { class: 'resize-cursor-vertical' } : null;
            },
            handleDOMEvents: {
                mousemove(view, event) {
                    if (!otherResizing(key, view.state)) {
                        handleMouseMove(view, event, handleWidth);
                    }
                    return false;
                },
                mouseleave(view) {
                    handleMouseLeave(view);
                    return false;
                },
                mousedown(view, event) {
                    return handleMouseDown(view, event);
                }
            },
            decorations(state) {
                if (otherResizing(key, state)) {
                    return DecorationSet.empty;
                }
                let pluginState = key.getState(state);
                if (pluginState.activeHandle > -1) {
                    return handleDecorations(state, pluginState.activeHandle);
                }
            },
            nodeViews: {}
        }
    });
    return plugin;
}
function pointsAtCell($pos) {
    return $pos.parent.type.spec.tableRole === 'row' && $pos.nodeAfter;
}
class ResizeState {
    constructor(activeHandle, dragging) {
        this.activeHandle = activeHandle;
        this.dragging = dragging;
    }
    apply(tr) {
        let state = this, action = tr.getMeta(key);
        if (action && action.setHandle != null) {
            return new ResizeState(action.setHandle, null);
        }
        if (action && action.setDragging !== undefined) {
            return new ResizeState(state.activeHandle, action.setDragging);
        }
        if (state.activeHandle > -1) {
            let handle = tr.mapping.map(state.activeHandle, -1);
            if (!pointsAtCell(tr.doc.resolve(handle))) {
                handle = null;
            }
            state = new ResizeState(handle, state.dragging);
        }
        return state;
    }
}
function handleMouseMove(view, event, handleWidth) {
    let pluginState = key.getState(view.state);
    if (!pluginState.dragging) {
        let target = domCellAround(event.target), row = -1;
        if (target) {
            const rowDom = target.parentNode;
            let domRect = rowDom.getBoundingClientRect();
            if (Math.abs(event.clientY - domRect.top) <= handleWidth && rowDom.rowIndex > 0) {
                row = edgeRow(view, event, rowDom.rowIndex - 1);
            }
            else if (domRect.bottom - event.clientY > 0 && domRect.bottom - event.clientY <= handleWidth) {
                row = edgeRow(view, event, rowDom.rowIndex);
            }
        }
        if (row !== pluginState.activeHandle) {
            updateHandle(view, row);
        }
    }
}
function handleMouseLeave(view) {
    let pluginState = key.getState(view.state);
    if (pluginState.activeHandle > -1 && !pluginState.dragging) {
        updateHandle(view, -1);
    }
}
function handleMouseDown(view, event) {
    let pluginState = key.getState(view.state);
    if (pluginState.activeHandle === -1 || pluginState.dragging) {
        return false;
    }
    const doc = view.state.doc;
    let $pos = doc.resolve(pluginState.activeHandle);
    let row = doc.nodeAt(pluginState.activeHandle);
    let table = $pos.parent;
    let rowHeightStr = parseStyle(row.attrs.style).height;
    let tableHeight = parseStyle(table.attrs.style).height;
    let rowHeight = rowHeightStr ? parseFloat(rowHeightStr) : 0;
    if (!rowHeightStr) {
        const tr = view.nodeDOM(pluginState.activeHandle);
        rowHeight = tr.offsetHeight;
    }
    view.dispatch(view.state.tr.setMeta(key, {
        setDragging: {
            startY: event.clientY,
            startHeight: { rowHeight, tableHeight }
        }
    }));
    function finish(ev) {
        ev.view.removeEventListener('mouseup', finish);
        ev.view.removeEventListener('mousemove', move);
        let curPluginState = key.getState(view.state);
        if (curPluginState.dragging) {
            const tr = view.state.tr.setMeta(key, { setDragging: null });
            updateRowHeight(view, tr, curPluginState.activeHandle);
            view.dispatch(tr);
        }
    }
    function move(ev) {
        if (!ev.which) {
            return finish(ev);
        }
        let curPluginState = key.getState(view.state);
        let dragged = draggedHeight(curPluginState.dragging, ev);
        let offset = ev.clientY - curPluginState.dragging.startY;
        displayRowHeight(view, curPluginState.activeHandle, dragged, offset, tableHeight);
    }
    event.view.addEventListener('mouseup', finish);
    event.view.addEventListener('mousemove', move);
    event.preventDefault();
    return true;
}
function edgeRow(view, event, rowIndex) {
    let found = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (!found) {
        return -1;
    }
    let $pos = view.state.doc.resolve(found.pos);
    let parentTable = parentNode($pos, n => n.type.spec.tableRole === 'table');
    if (parentTable === null) {
        return -1;
    }
    let tablePos = $pos.start(parentTable.depth);
    const tableNode = parentTable.node;
    const map = TableMap.get(tableNode);
    const row = tablePos + map.map[(map.width * rowIndex)] - 1;
    return row;
}
function draggedHeight(dragging, event) {
    let offset = event.clientY - dragging.startY;
    return dragging.startHeight.rowHeight + offset;
}
function updateHandle(view, value) {
    const tr = view.state.tr;
    tr.setMeta('addToHistory', false);
    tr.setMeta(key, { setHandle: value });
    view.dispatch(tr);
}
function updateRowHeight(view, tr, rowPos) {
    const doc = view.state.doc;
    let row = doc.nodeAt(rowPos);
    const dom = view.nodeDOM(rowPos);
    const win = (dom.ownerDocument && dom.ownerDocument.defaultView) || window;
    dom.style.height = win.getComputedStyle(dom).height;
    tr.setNodeMarkup(rowPos, null, setNodeStyle(row.attrs, 'height', dom.style.height));
    const table = dom && dom.closest('table');
    const tableHeight = table && table.style.height;
    if (tableHeight) {
        let $pos = doc.resolve(rowPos);
        let tablePos = $pos.start($pos.depth) - 1;
        tr.setNodeMarkup(tablePos, null, setNodeStyle($pos.parent.attrs, 'height', tableHeight));
    }
}
function displayRowHeight(view, rowPos, height, offset, tableHeight) {
    const dom = view.nodeDOM(rowPos);
    if (dom) {
        dom.style.height = height + 'px';
        const win = (dom.ownerDocument && dom.ownerDocument.defaultView) || window;
        dom.style.height = win.getComputedStyle(dom).height;
        const table = dom.closest('table');
        const newHeight = (parseFloat(tableHeight) + offset) + 'px';
        const current = table && table.style.height;
        if (current && current !== newHeight) {
            table.style.height = (parseFloat(tableHeight) + offset) + 'px';
            table.style.height = win.getComputedStyle(table).height;
        }
    }
}
function handleDecorations(state, pos) {
    let decorations = [];
    if (typeof pos !== 'number') {
        return DecorationSet.empty;
    }
    let $row = state.doc.resolve(pos), table = $row.parent, map = TableMap.get(table), rowIndex = $row.index($row.depth), start = $row.start($row.depth);
    for (let col = 0; col < map.width; col++) {
        let index = col + rowIndex * map.width;
        let cellPos = map.map[index];
        const cell = table.nodeAt(cellPos);
        let widgetPos = start + cellPos + (cell ? cell.nodeSize : 0) - 1;
        let dom = document.createElement('div');
        dom.className = 'row-resize-handle';
        decorations.push(Decoration.widget(widgetPos, dom));
    }
    return DecorationSet.create(state.doc, decorations);
}
