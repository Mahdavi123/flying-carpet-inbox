import { Plugin } from 'prosemirror-state';
import { TableMap, tableNodeTypes } from 'prosemirror-tables-ts';
import { Decoration, DecorationSet } from 'prosemirror-view';
import { domCellAround, otherResizeHandle, otherResizing, parentNode, parseStyle, setNodeStyle, tableRowResizeKey as key } from './utils';
var TableRowView = /** @class */ (function () {
    function TableRowView() {
    }
    TableRowView.prototype.ignoreMutation = function (record) {
        return record.type === 'attributes' && record.attributeName === 'style' && record.target.nodeName === 'TR';
    };
    return TableRowView;
}());
export function rowResizing() {
    var handleWidth = 5;
    var plugin = new Plugin({
        key: key,
        state: {
            init: function (_, state) {
                this.spec.props.nodeViews[tableNodeTypes(state.schema).row.name] = function (_node, _view) { return new TableRowView(); };
                return new ResizeState(-1, null);
            },
            apply: function (tr, prev) {
                return prev.apply(tr);
            }
        },
        props: {
            attributes: function (state) {
                if (otherResizeHandle(key, state)) {
                    return null;
                }
                var pluginState = key.getState(state);
                return pluginState.activeHandle > -1 ? { class: 'resize-cursor-vertical' } : null;
            },
            handleDOMEvents: {
                mousemove: function (view, event) {
                    if (!otherResizing(key, view.state)) {
                        handleMouseMove(view, event, handleWidth);
                    }
                    return false;
                },
                mouseleave: function (view) {
                    handleMouseLeave(view);
                    return false;
                },
                mousedown: function (view, event) {
                    return handleMouseDown(view, event);
                }
            },
            decorations: function (state) {
                if (otherResizing(key, state)) {
                    return DecorationSet.empty;
                }
                var pluginState = key.getState(state);
                if (pluginState.activeHandle > -1) {
                    return handleDecorations(state, pluginState.activeHandle);
                }
            },
            nodeViews: {}
        }
    });
    return plugin;
}
function pointsAtCell($pos) {
    return $pos.parent.type.spec.tableRole === 'row' && $pos.nodeAfter;
}
var ResizeState = /** @class */ (function () {
    function ResizeState(activeHandle, dragging) {
        this.activeHandle = activeHandle;
        this.dragging = dragging;
    }
    ResizeState.prototype.apply = function (tr) {
        var state = this, action = tr.getMeta(key);
        if (action && action.setHandle != null) {
            return new ResizeState(action.setHandle, null);
        }
        if (action && action.setDragging !== undefined) {
            return new ResizeState(state.activeHandle, action.setDragging);
        }
        if (state.activeHandle > -1) {
            var handle = tr.mapping.map(state.activeHandle, -1);
            if (!pointsAtCell(tr.doc.resolve(handle))) {
                handle = null;
            }
            state = new ResizeState(handle, state.dragging);
        }
        return state;
    };
    return ResizeState;
}());
function handleMouseMove(view, event, handleWidth) {
    var pluginState = key.getState(view.state);
    if (!pluginState.dragging) {
        var target = domCellAround(event.target), row = -1;
        if (target) {
            var rowDom = target.parentNode;
            var domRect = rowDom.getBoundingClientRect();
            if (Math.abs(event.clientY - domRect.top) <= handleWidth && rowDom.rowIndex > 0) {
                row = edgeRow(view, event, rowDom.rowIndex - 1);
            }
            else if (domRect.bottom - event.clientY > 0 && domRect.bottom - event.clientY <= handleWidth) {
                row = edgeRow(view, event, rowDom.rowIndex);
            }
        }
        if (row !== pluginState.activeHandle) {
            updateHandle(view, row);
        }
    }
}
function handleMouseLeave(view) {
    var pluginState = key.getState(view.state);
    if (pluginState.activeHandle > -1 && !pluginState.dragging) {
        updateHandle(view, -1);
    }
}
function handleMouseDown(view, event) {
    var pluginState = key.getState(view.state);
    if (pluginState.activeHandle === -1 || pluginState.dragging) {
        return false;
    }
    var doc = view.state.doc;
    var $pos = doc.resolve(pluginState.activeHandle);
    var row = doc.nodeAt(pluginState.activeHandle);
    var table = $pos.parent;
    var rowHeightStr = parseStyle(row.attrs.style).height;
    var tableHeight = parseStyle(table.attrs.style).height;
    var rowHeight = rowHeightStr ? parseFloat(rowHeightStr) : 0;
    if (!rowHeightStr) {
        var tr = view.nodeDOM(pluginState.activeHandle);
        rowHeight = tr.offsetHeight;
    }
    view.dispatch(view.state.tr.setMeta(key, {
        setDragging: {
            startY: event.clientY,
            startHeight: { rowHeight: rowHeight, tableHeight: tableHeight }
        }
    }));
    function finish(ev) {
        ev.view.removeEventListener('mouseup', finish);
        ev.view.removeEventListener('mousemove', move);
        var curPluginState = key.getState(view.state);
        if (curPluginState.dragging) {
            var tr = view.state.tr.setMeta(key, { setDragging: null });
            updateRowHeight(view, tr, curPluginState.activeHandle);
            view.dispatch(tr);
        }
    }
    function move(ev) {
        if (!ev.which) {
            return finish(ev);
        }
        var curPluginState = key.getState(view.state);
        var dragged = draggedHeight(curPluginState.dragging, ev);
        var offset = ev.clientY - curPluginState.dragging.startY;
        displayRowHeight(view, curPluginState.activeHandle, dragged, offset, tableHeight);
    }
    event.view.addEventListener('mouseup', finish);
    event.view.addEventListener('mousemove', move);
    event.preventDefault();
    return true;
}
function edgeRow(view, event, rowIndex) {
    var found = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (!found) {
        return -1;
    }
    var $pos = view.state.doc.resolve(found.pos);
    var parentTable = parentNode($pos, function (n) { return n.type.spec.tableRole === 'table'; });
    if (parentTable === null) {
        return -1;
    }
    var tablePos = $pos.start(parentTable.depth);
    var tableNode = parentTable.node;
    var map = TableMap.get(tableNode);
    var row = tablePos + map.map[(map.width * rowIndex)] - 1;
    return row;
}
function draggedHeight(dragging, event) {
    var offset = event.clientY - dragging.startY;
    return dragging.startHeight.rowHeight + offset;
}
function updateHandle(view, value) {
    var tr = view.state.tr;
    tr.setMeta('addToHistory', false);
    tr.setMeta(key, { setHandle: value });
    view.dispatch(tr);
}
function updateRowHeight(view, tr, rowPos) {
    var doc = view.state.doc;
    var row = doc.nodeAt(rowPos);
    var dom = view.nodeDOM(rowPos);
    var win = (dom.ownerDocument && dom.ownerDocument.defaultView) || window;
    dom.style.height = win.getComputedStyle(dom).height;
    tr.setNodeMarkup(rowPos, null, setNodeStyle(row.attrs, 'height', dom.style.height));
    var table = dom && dom.closest('table');
    var tableHeight = table && table.style.height;
    if (tableHeight) {
        var $pos = doc.resolve(rowPos);
        var tablePos = $pos.start($pos.depth) - 1;
        tr.setNodeMarkup(tablePos, null, setNodeStyle($pos.parent.attrs, 'height', tableHeight));
    }
}
function displayRowHeight(view, rowPos, height, offset, tableHeight) {
    var dom = view.nodeDOM(rowPos);
    if (dom) {
        dom.style.height = height + 'px';
        var win = (dom.ownerDocument && dom.ownerDocument.defaultView) || window;
        dom.style.height = win.getComputedStyle(dom).height;
        var table = dom.closest('table');
        var newHeight = (parseFloat(tableHeight) + offset) + 'px';
        var current = table && table.style.height;
        if (current && current !== newHeight) {
            table.style.height = (parseFloat(tableHeight) + offset) + 'px';
            table.style.height = win.getComputedStyle(table).height;
        }
    }
}
function handleDecorations(state, pos) {
    var decorations = [];
    if (typeof pos !== 'number') {
        return DecorationSet.empty;
    }
    var $row = state.doc.resolve(pos), table = $row.parent, map = TableMap.get(table), rowIndex = $row.index($row.depth), start = $row.start($row.depth);
    for (var col = 0; col < map.width; col++) {
        var index = col + rowIndex * map.width;
        var cellPos = map.map[index];
        var cell = table.nodeAt(cellPos);
        var widgetPos = start + cellPos + (cell ? cell.nodeSize : 0) - 1;
        var dom = document.createElement('div');
        dom.className = 'row-resize-handle';
        decorations.push(Decoration.widget(widgetPos, dom));
    }
    return DecorationSet.create(state.doc, decorations);
}
