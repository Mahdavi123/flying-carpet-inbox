"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pmAddRowAfter = exports.pmAddRowBefore = exports.addRowAfter = exports.addRowBefore = exports.createTable = void 0;
var prosemirror_tables_ts_1 = require("prosemirror-tables-ts");
Object.defineProperty(exports, "pmAddRowAfter", { enumerable: true, get: function () { return prosemirror_tables_ts_1.addRowAfter; } });
Object.defineProperty(exports, "pmAddRowBefore", { enumerable: true, get: function () { return prosemirror_tables_ts_1.addRowBefore; } });
var constants_1 = require("./config/constants");
/**
 * Creates a table.
 * @returns Node
 */
var createTable = function (nodes, rows, columns) {
    var table = nodes.table, table_row = nodes.table_row, table_cell = nodes.table_cell;
    var tableRows = [];
    var cells;
    for (var r = 0; r < rows + 1; r++) {
        cells = [];
        for (var c = 0; c < columns + 1; c++) {
            cells.push(table_cell.createAndFill());
        }
        tableRows.push(table_row.createAndFill(undefined, cells));
    }
    return table.createAndFill(undefined, tableRows);
};
exports.createTable = createTable;
var closest = function (selection, name) {
    var pos = selection.$head;
    for (var i = pos.depth; i > 0; i--) {
        var node = pos.node(i);
        if (node.type.name === name) {
            return {
                pos: pos.before(i),
                node: node
            };
        }
    }
    return null;
};
var addRowBefore = function (state, dispatch) {
    var cmdDispatch = dispatch && (function (tr) {
        var _a;
        var row = closest(tr.selection, 'table_row');
        var table = closest(tr.selection, 'table');
        if (row && table && row.node.attrs[constants_1.rowTypeAttr]) {
            var index = 0;
            for (var i = 0; i < table.node.nodeSize; i++) {
                if (table.node.child(i).eq(row.node)) {
                    index = i;
                    break;
                }
            }
            var next = table.node.child(index - 1);
            var from = row.pos - next.nodeSize;
            tr.setNodeMarkup(from, undefined, (_a = {}, _a[constants_1.rowTypeAttr] = row.node.attrs[constants_1.rowTypeAttr], _a));
        }
        return dispatch(tr);
    });
    return prosemirror_tables_ts_1.addRowBefore(state, cmdDispatch);
};
exports.addRowBefore = addRowBefore;
var addRowAfter = function (state, dispatch) {
    var cmdDispatch = dispatch && (function (tr) {
        var _a;
        var row = closest(tr.selection, 'table_row');
        if (row && row.node.attrs[constants_1.rowTypeAttr]) {
            var from = row.pos + row.node.nodeSize;
            tr.setNodeMarkup(from, undefined, (_a = {}, _a[constants_1.rowTypeAttr] = row.node.attrs[constants_1.rowTypeAttr], _a));
        }
        return dispatch(tr);
    });
    return prosemirror_tables_ts_1.addRowAfter(state, cmdDispatch);
};
exports.addRowAfter = addRowAfter;
